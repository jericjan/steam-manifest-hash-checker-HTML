<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Steam Manifest/SHA1 Hash Checker</title>
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
    <!-- Required external resources -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Roboto+Mono&display=swap"
        rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/hash-wasm@4.11.0/dist/sha1.umd.min.js"></script>
    <style>
        :root[data-theme="dark"] {
            --bg: #121212;
            --text: #e0e0e0;
            --border: #2f2f2f;
            --hover: #1f1f1f;
            --primary: #808080;
            --primary-dark: #666666;
            --primary-light: #a0a0a0;
            --metallic: linear-gradient(145deg, #1a1a1a, #121212);
            --metallic-hover: linear-gradient(145deg, #1f1f1f, #171717);
            --accent: #808080;
            --success: #4caf50;
            --error: #f44336;
            --warning: #ff9800;
        }
        :root[data-theme="blue"] {
            --bg: #1a1f2e;
            --text: #e0e6f2;
            --border: #2a3242;
            --hover: #2d344c;
            --primary: #4a74c9;
            --primary-dark: #385fa8;
            --primary-light: #6189d8;
            --metallic: linear-gradient(145deg, #2a3242, #1e2433);
            --metallic-hover: linear-gradient(145deg, #2d344c, #212737);
            --accent: #64b5f6;
            --success: #4caf50;
            --error: #f44336;
            --warning: #ff9800;
        }
        :root[data-theme="light"] {
            --bg: #ffffff;
            --text: #333333;
            --border: #dddddd;
            --hover: #f5f5f5;
            --primary: #555555;
            --primary-dark: #e0e0e0;
            --primary-light: #666666;
            --metallic: linear-gradient(145deg, #ffffff, #f8f8f8);
            --metallic-hover: linear-gradient(145deg, #f8f8f8, #f0f0f0);
            --accent: #555555;
            --success: #4caf50;
            --error: #f44336;
            --warning: #ff9800;
        }
        :root[data-theme="steam"] {
            --bg: #171a21;
            --text: #c6d4df;
            --border: #2a475e;
            --hover: #1b2838;
            --primary: #66c0f4;
            --primary-dark: #1b2838;
            --primary-light: #c7d5e0;
            --metallic: linear-gradient(145deg, #1b2838, #171a21);
            --metallic-hover: linear-gradient(145deg, #2a475e, #1b2838);
            --accent: #66c0f4;
            --success: #a4d007;
            --error: #cc3d3d;
            --warning: #ffa500;
        }
        :root[data-theme="synthwave"] {
            --bg: #1a1a2e;
            --text: #ff9ecd;
            --border: #342c56;
            --hover: #261d47;
            --primary: #f97bc1;
            --primary-dark: #fc2fa2;
            --primary-light: #ffb8e0;
            --metallic: linear-gradient(145deg, #2d1f54, #1a1a2e);
            --metallic-hover: linear-gradient(145deg, #342c56, #2d1f54);
            --accent: #3bfff9;
            --success: #72f1b8;
            --error: #ff3d81;
            --warning: #ffd319;
        }
        :root[data-theme="ocean"] {
            --bg: #0a192f;
            --text: #8892b0;
            --border: #1b3a57;
            --hover: #172a45;
            --primary: #64ffda;
            --primary-dark: #48d6b5;
            --primary-light: #7fffdf;
            --metallic: linear-gradient(145deg, #1b3a57, #0a192f);
            --metallic-hover: linear-gradient(145deg, #234668, #1b3a57);
            --accent: #00b4d8;
            --success: #2dd4bf;
            --error: #ef476f;
            --warning: #ffd60a;
        }
        :root[data-theme="forest"] {
            --bg: #1b2717;
            --text: #d8e2d5;
            --border: #2d3f24;
            --hover: #233019;
            --primary: #90b474;
            --primary-dark: #6a9547;
            --primary-light: #b1cc9a;
            --metallic: linear-gradient(145deg, #2d3f24, #1b2717);
            --metallic-hover: linear-gradient(145deg, #34492a, #2d3f24);
            --accent: #e9f5db;
            --success: #77dd77;
            --error: #ff6b6b;
            --warning: #ffd93d;
        }
        :root[data-theme="solarized"] {
            --bg: #002b36;
            --text: #839496;
            --border: #073642;
            --hover: #003847;
            --primary: #2aa198;
            --primary-dark: #1f7972;
            --primary-light: #35c8bd;
            --metallic: linear-gradient(145deg, #073642, #002b36);
            --metallic-hover: linear-gradient(145deg, #0b4653, #073642);
            --accent: #268bd2;
            --success: #859900;
            --error: #dc322f;
            --warning: #b58900;
        }
        :root {
            --radius: 12px;
            --shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            --transition: all 0.3s ease;
        }
        /* Loading overlay styles */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 1000;
        }
        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid var(--border);
            border-top: 3px solid var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        .loading-text {
            color: var(--text);
            margin-top: 1rem;
            font-size: 1.2rem;
        }
        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }
        body {
            font-family: 'Inter', system-ui, sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.6;
            margin: 0;
            min-height: 100vh;
        }
        .container {
            max-width: 1920px;
            margin: 0 auto;
            padding: 0 2rem;
            display: flex;
            flex-direction: column;
        }
        .header {
            background: var(--metallic);
            padding: 1.5rem 2rem;
            box-shadow: var(--shadow);
            margin-bottom: 2rem;
            border-bottom: 1px solid var(--border);
        }
        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .header h1 {
            margin: 0;
            font-size: 1.75rem;
            font-weight: 600;
            color: var(--primary-light);
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        .header-controls {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        .theme-toggle {
            position: relative;
        }
        .theme-toggle select {
            appearance: none;
            background: var(--metallic);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 0.5rem 2.5rem 0.5rem 1rem;
            border-radius: var(--radius);
            cursor: pointer;
            transition: var(--transition);
            font-family: inherit;
            font-size: 0.9rem;
        }
        .theme-toggle select:hover {
            background: var(--metallic-hover);
            border-color: var(--primary);
        }
        .theme-toggle select option {
            background: var(--bg);
            color: var(--text);
            padding: 0.5rem;
        }
        .theme-toggle::after {
            content: "palette";
            font-family: "Material Icons";
            position: absolute;
            right: 0.75rem;
            top: 50%;
            transform: translateY(-50%);
            pointer-events: none;
            color: var(--text);
        }
        .toggle-button {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: var(--metallic);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 0.5rem 1rem;
            border-radius: var(--radius);
            cursor: pointer;
            transition: var(--transition);
        }
        .toggle-button:hover {
            background: var(--metallic-hover);
            border-color: var(--primary);
        }
        .toggle-button .material-icons {
            font-size: 1.25rem;
        }
        .dropzones {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
        }
        .dropzone {
            flex: 1;
            border: 2px dashed var(--primary);
            border-radius: var(--radius);
            padding: 2rem;
            text-align: center;
            cursor: pointer;
            background: var(--metallic);
            transition: var(--transition);
            box-shadow: var(--shadow);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            position: relative;
        }
        .dropzone input {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            cursor: pointer;
        }
        .dropzone textarea {
            position: relative;
            width: 100%;
            height: 100px;
            background: var(--metallic);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 0.5rem;
            border-radius: var(--radius);
            resize: none;
            font-family: 'Roboto Mono', monospace;
            font-size: 0.9rem;
            z-index: 1;
        }
        .dropzone textarea::-webkit-scrollbar {
            display: none;
        }
        .dropzone:hover,
        .dropzone.drag-over {
            background: var(--metallic-hover);
            border-color: var(--primary-light);
            transform: translateY(-2px);
        }
        .section {
            background: var(--metallic);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            box-shadow: var(--shadow);
        }
        .progress-container {
            margin: 1.5rem 0;
            background: var(--metallic);
            padding: 1.5rem;
            border-radius: var(--radius);
            border: 1px solid var(--border);
        }
        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--border);
            border-radius: 4px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary) 0%, var(--primary-light) 100%);
            width: 0;
            transition: width 0.3s ease;
        }
        .table-container {
            overflow-x: auto;
            border: 1px solid var(--border);
            border-radius: 8px;
            background: rgba(42, 50, 66, 0.5);
        }
        table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            table-layout: auto;
        }
        th {
            position: sticky;
            top: 0;
            background: var(--primary-dark);
            color: var(--text);
            border-bottom: 2px solid var(--border);
            padding: 0.75rem 1rem;
            font-weight: 500;
            text-align: left;
            white-space: nowrap;
        }
        .language-selector select option {
            background: var(--bg);
            color: var(--text);
            padding: 0.5rem;
        }
        [data-theme="light"] .language-selector select option {
            background: #ffffff;
            color: #333333;
        }
        [data-theme="light"] th {
            color: #333333 !important;
            background: #e0e0e0;
        }
        [data-theme="light"] .dropzone {
            border-color: #555555;
            color: #333333;
        }
        [data-theme="light"] .material-icons {
            color: #555555;
        }
        [data-theme="light"] .dropzone:hover,
        [data-theme="light"] .dropzone.drag-over {
            border-color: #333333;
            background: var(--hover);
        }
        td {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--border);
            white-space: nowrap;
        }
        .status {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }
        .match {
            color: var(--success);
        }
        .mismatch {
            color: var(--error);
        }
        .pending {
            color: var(--warning);
        }
        .folder {
            color: var(--accent);
        }
        .hidden {
            display: none !important;
        }
        .error {
            color: var(--error);
            background: rgba(244, 67, 54, 0.1);
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            border: 1px solid rgba(244, 67, 54, 0.2);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        @media (max-width: 768px) {
            .container {
                padding: 0 1rem;
            }
            .dropzones {
                flex-direction: column;
            }
            .dropzone {
                padding: 1.5rem;
            }
        }
        /* Language selector styles */
        .language-selector {
            margin-right: 1rem;
            position: relative;
        }
        .language-selector select {
            appearance: none;
            background: var(--metallic);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 0.5rem 2.5rem 0.5rem 1rem;
            border-radius: var(--radius);
            cursor: pointer;
            transition: var(--transition);
            font-family: inherit;
            font-size: 0.9rem;
        }
        .language-selector select:hover {
            background: var(--metallic-hover);
            border-color: var(--primary);
        }
        .language-selector::after {
            content: "language";
            font-family: "Material Icons";
            position: absolute;
            right: 0.75rem;
            top: 50%;
            transform: translateY(-50%);
            pointer-events: none;
            color: var(--text);
        }
    </style>
</head>
<body>
    <div id="loading-overlay" class="loading-overlay hidden">
        <div class="loading-spinner"></div>
        <div class="loading-text" data-lang="ui.loading">Loading...</div>
    </div>
    <header class="header">
        <div class="header-content">
            <h1><span class="material-icons">verified</span> <span data-lang="app.title">Steam Manifest/SHA1
                    Checker</span></h1>
            <div class="header-controls">
                <div class="language-selector">
                    <select id="language-select">
                        <option value="en">English</option>
                        <option value="es">Español</option>
                        <option value="de">Deutsch</option>
                        <option value="fr">Français</option>
                        <option value="jp">日本語</option>
                        <option value="ru">Русский</option>
                        <option value="zh">中文</option>
                    </select>
                </div>
                <div class="theme-toggle">
                    <select id="theme-select">
                        <option value="dark">Dark Theme</option>
                        <option value="blue">Blue Theme</option>
                        <option value="light">Light Theme</option>
                        <option value="steam">Steam Theme</option>
                        <option value="synthwave">Synthwave Theme</option>
                        <option value="ocean">Ocean Theme</option>
                        <option value="forest">Forest Theme</option>
                        <option value="solarized">Solarized Theme</option>
                    </select>
                </div>
                <button id="folder-toggle" class="toggle-button">
                    <span class="material-icons">folder</span>
                    <span id="folder-toggle-text" data-lang="app.folderToggle.hide">Hide Folders</span>
                </button>
            </div>
        </div>
    </header>
    <div class="container">
        <div class="dropzones">
            <div class="dropzone" id="drop-zone">
                <span class="material-icons">upload_file</span>
                <span data-lang="dropzones.manifest">Drop Steam manifest or SHA1 file here</span>
                <input type="file" id="file-input">
                <span data-lang="dropzones.orInput">Or enter SHA1 hashes into the textarea below</span>
                <textarea id="raw-input" placeholder="SHA1 hashes here" data-lang-placeholder="dropzones.textareaPlaceholder"></textarea>
            </div>
            <div class="dropzone" id="dir-zone">
                <span class="material-icons">folder_open</span>
                <span data-lang="dropzones.folder">Drop folder to verify here</span>
                <input type="file" id="dir-input" webkitdirectory directory>
            </div>
        </div>
        <div id="error" class="error hidden">
            <span class="material-icons">error</span>
            <span class="error-message"></span>
        </div>
        <div id="metadata" class="section hidden">
            <h2>
                <span class="material-icons">info</span>
                <span data-lang="fileInfo.title">File Info</span>
            </h2>
            <table>
                <tr>
                    <td data-lang="fileInfo.type">Type:</td>
                    <td id="file-type"></td>
                </tr>
                <tr>
                    <td data-lang="fileInfo.depotId">Depot ID:</td>
                    <td id="depot-id"></td>
                </tr>
                <tr>
                    <td data-lang="fileInfo.manifestId">Manifest ID:</td>
                    <td id="manifest-gid"></td>
                </tr>
                <tr>
                    <td data-lang="fileInfo.creationDate">Creation Date:</td>
                    <td id="creation-time"></td>
                </tr>
                <tr>
                    <td data-lang="fileInfo.totalFiles">Total Files:</td>
                    <td id="total-files"></td>
                </tr>
                <tr>
                    <td data-lang="fileInfo.status">Status:</td>
                    <td id="completion-status" data-lang="status.notStarted">Not Started</td>
                </tr>
                <tr>
                    <td data-lang="fileInfo.totalSize">Total Size:</td>
                    <td id="total-size"></td>
                </tr>
            </table>
        </div>
        <div id="mismatches" class="section hidden">
            <h2>
                <span class="material-icons" style="color: var(--error);">warning</span>
                <span data-lang="mismatches.title">Mismatched Files</span>
            </h2>
            <div class="table-container">
                <table>
                    <thead>
                        <tr>
                            <th style="width: 40%" data-lang="mismatches.columns.filename">Filename</th>
                            <th style="width: 10%" data-lang="mismatches.columns.size">Size</th>
                            <th style="width: 25%" data-lang="mismatches.columns.expectedHash">Expected Hash</th>
                            <th style="width: 25%" data-lang="mismatches.columns.actualHash">Actual Hash</th>
                        </tr>
                    </thead>
                    <tbody id="mismatch-list"></tbody>
                </table>
            </div>
        </div>
        <div id="files" class="section hidden">
            <h2>
                <span class="material-icons">folder</span>
                <span data-lang="files.title">Files</span>
            </h2>
            <div class="table-container">
                <table>
                    <thead>
                        <tr>
                            <th style="width: 40%" data-lang="files.columns.filename">Filename</th>
                            <th style="width: 10%" data-lang="files.columns.size">Size</th>
                            <th style="width: 25%" data-lang="files.columns.hash">Hash</th>
                            <th style="width: 25%" data-lang="files.columns.status">Status</th>
                        </tr>
                    </thead>
                    <tbody id="file-list"></tbody>
                </table>
            </div>
        </div>
    </div>
    <script>
        // Utility class for reading binary data
        class BinaryReader {
            constructor(buffer) {
                this.view = new DataView(buffer);
                this.offset = 0;
            }
            readUint32() {
                const value = this.view.getUint32(this.offset, true);
                this.offset += 4;
                return value;
            }
            readBytes(length) {
                const bytes = new Uint8Array(this.view.buffer, this.offset, length);
                this.offset += length;
                return bytes;
            }
            hasMore() {
                return this.offset < this.view.byteLength;
            }
        }
        // Language Manager class
        class LanguageManager {
            constructor(baseUrl) {
                this.baseUrl = baseUrl;
                this.currentLanguage = localStorage.getItem('language');
                // Auto-select language from browser UI language if unset
                if (!this.currentLanguage) {
                    const supportedLanguages = Array.from(document.getElementById('language-select').options).map(o => o.value);
                    this.currentLanguage = navigator.languages.map(l => l.substring(0, 2)).find(l => supportedLanguages.includes(l)) || 'en';
                }
                this.strings = null;
                this.loadingPromise = null;
                this.fallbackStrings = {
                    // Default English strings in case language files can't be loaded
                    "app.title": "Steam Manifest/SHA1 Checker",
                    "fileInfo.types.steam": "Steam Manifest",
                    "fileInfo.types.sha1": "SHA1 File",
                    "status.match": "Match",
                    "status.mismatch": "Mismatch",
                    "status.pending": "Pending",
                    "status.folder": "Folder",
                    "status.notStarted": "Not Started",
                    "errors.loadManifest": "Load manifest or SHA1 file first",
                    "errors.noFiles": "No files selected",
                    "errors.invalidFormat": "Invalid file format:",
                    "errors.noValidHashes": "No valid SHA1 hashes found in file",
                    "errors.fileMissing": "File Missing",
                    "ui.loading": "Loading..."
                };
            }
            // Initialize the language manager
            async init() {
                try {
                    await this.loadLanguage(this.currentLanguage);
                } catch (error) {
                    console.error('Failed to load language file, using fallback strings');
                    this.strings = this.fallbackStrings;
                }
                this.updateUI();
                this.initLanguageSelector();
            }
            // Load language strings from URL
            async loadLanguage(lang) {
                try {
                    const response = await fetch(`${this.baseUrl}/languages/${lang}.json`);
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    this.strings = await response.json();
                    this.currentLanguage = lang;
                    localStorage.setItem('language', lang);
                } catch (error) {
                    console.error(`Failed to load language '${lang}':`, error);
                    this.strings = this.fallbackStrings;
                    if (lang !== 'en') {
                        return this.loadLanguage('en');
                    }
                    throw error;
                }
            }
            // Get a string by its path
            getString(path) {
                if (!this.strings) return this.fallbackStrings[path] || path;
                return path.split('.').reduce((obj, key) => obj?.[key], this.strings) ||
                    this.fallbackStrings[path] || path;
            }
            // Update UI with current language strings
            updateUI() {
                // Update title
                document.title = this.getString('app.title');
                // Update all elements with data-lang attribute
                document.querySelectorAll('[data-lang]').forEach(element => {
                    const key = element.getAttribute('data-lang');
                    element.textContent = this.getString(key);
                });
                // data-lang-placeholder
                document.querySelectorAll('[data-lang-placeholder]').forEach(element => {
                    const key = element.getAttribute('data-lang-placeholder');
                    element.setAttribute('placeholder', this.getString(key));
                });
                // If there's a manifest loaded, refresh it
                if (window.currentManifest) {
                    displayManifest(window.currentManifest);
                }
            }
            // Add language selector to the UI
            initLanguageSelector() {
                const select = document.getElementById('language-select');
                select.value = this.currentLanguage;
                select.addEventListener('change', (e) => {
                    this.loadLanguage(e.target.value).then(() => this.updateUI());
                });
            }
        }
        // Progress Manager class to handle the progress bar
        const ProgressManager = {
            container: null,
            create() {
                this.container = document.createElement('div');
                this.container.className = 'progress-container';
                this.container.innerHTML = `
                    <div class="progress-bar">
                        <div class="progress-fill"></div>
                    </div>
                    <div class="progress-stats">
                        <div class="progress-text">
                            <span class="material-icons">task_alt</span>
                            <span>Matched: 
                                <span id="matched-count">0</span>/
                                <span id="total-checkable">0</span>
                            </span>
                            <span class="speed-info">Speed: 
                                <span id="hash-speed">0 MB/s</span>
                            </span>
                        </div>
                    </div>
                `;
                document.querySelector('.container').insertBefore(
                    this.container,
                    document.getElementById('files')
                );
                return this.container;
            },
            update(stats) {
                if (!this.container) return;
                const progress = (stats.matches / stats.total) * 100;
                this.container.querySelector('.progress-fill').style.width = `${progress}%`;
                this.container.querySelector('#matched-count').textContent = stats.matches;
                this.container.querySelector('#total-checkable').textContent = stats.total;
                this.container.querySelector('#hash-speed').textContent = stats.speed;
            },
            remove() {
                if (this.container) {
                    this.container.remove();
                    this.container = null;
                }
            }
        };
        // Steam Manifest Parser Class
        class Manifest {
            static PAYLOAD_MAGIC = 0x71F617D0;
            static METADATA_MAGIC = 0x1F4812BE;
            static ENDOFMANIFEST_MAGIC = 0x32C415AB;
            static async fromBuffer(buffer) {
                const reader = new BinaryReader(buffer);
                const manifest = {
                    Files: [],
                    DepotID: 0,
                    ManifestGID: 0,
                    CreationTime: new Date(),
                    TotalSize: 0
                };
                while (reader.hasMore()) {
                    const magic = reader.readUint32();
                    if (magic === this.ENDOFMANIFEST_MAGIC) break;
                    const length = reader.readUint32();
                    const data = reader.readBytes(length);
                    if (magic === this.PAYLOAD_MAGIC) {
                        this.parsePayload(data, manifest);
                    } else if (magic === this.METADATA_MAGIC) {
                        this.parseMetadata(data, manifest);
                    }
                }
                return manifest;
            }
            static parseVarint(bytes, offset = 0) {
                let value = 0n;
                let shift = 0n;
                let index = offset;
                while (index < bytes.length) {
                    const byte = bytes[index++];
                    value |= BigInt(byte & 0x7F) << shift;
                    if ((byte & 0x80) === 0) break;
                    shift += 7n;
                }
                return [value, index - offset];
            }
            static parseProtoField(bytes, offset) {
                const [tag, tagLen] = this.parseVarint(bytes, offset);
                const fieldNum = Number(tag >> 3n);
                const wireType = Number(tag & 0x07n);
                offset += tagLen;
                let value, valueLen;
                if (wireType === 0) {
                    [value, valueLen] = this.parseVarint(bytes, offset);
                } else if (wireType === 2) {
                    [value, valueLen] = this.parseVarint(bytes, offset);
                    const strLen = Number(value);
                    value = bytes.slice(offset + valueLen, offset + valueLen + strLen);
                    valueLen += strLen;
                }
                return {
                    fieldNum,
                    value,
                    bytesRead: tagLen + valueLen
                };
            }
            static parsePayload(data, manifest) {
                let offset = 0;
                while (offset < data.length) {
                    const field = this.parseProtoField(data, offset);
                    offset += field.bytesRead;
                    if (field.fieldNum === 1) {
                        const mapping = field.value;
                        let mappingOffset = 0;
                        const fileInfo = {
                            FileName: '',
                            FileHash: new Uint8Array(),
                            TotalSize: 0
                        };
                        while (mappingOffset < mapping.length) {
                            const mappingField = this.parseProtoField(mapping, mappingOffset);
                            mappingOffset += mappingField.bytesRead;
                            switch (mappingField.fieldNum) {
                                case 1:
                                    fileInfo.FileName = new TextDecoder().decode(mappingField.value);
                                    break;
                                case 2:
                                    fileInfo.TotalSize = Number(mappingField.value);
                                    break;
                                case 5:
                                    fileInfo.FileHash = mappingField.value;
                                    break;
                            }
                        }
                        if (fileInfo.FileName) manifest.Files.push(fileInfo);
                    }
                }
            }
            static parseMetadata(data, manifest) {
                let offset = 0;
                while (offset < data.length) {
                    const field = this.parseProtoField(data, offset);
                    offset += field.bytesRead;
                    switch (field.fieldNum) {
                        case 1:
                            manifest.DepotID = Number(field.value);
                            break;
                        case 2:
                            manifest.ManifestGID = field.value;
                            break;
                        case 3:
                            manifest.CreationTime = new Date(Number(field.value) * 1000);
                            break;
                        case 5:
                            manifest.TotalSize = Number(field.value);
                            break;
                    }
                }
            }
        }
        // File Processing Utilities
        const FileProcessor = {
            async readChunk(file, offset, length) {
                return new Promise(resolve => {
                    const reader = new FileReader();
                    reader.onload = e => resolve(e.target.result);
                    reader.readAsArrayBuffer(file.slice(offset, offset + length));
                });
            },
            getRelativePath(file) {
                let relativePath = file.webkitRelativePath;
                if (!relativePath) {
                    return file.name;
                }
                const pathParts = relativePath.split('/');
                return pathParts.length > 1 ? pathParts.slice(1).join('/') : file.name;
            },
            createMismatchRow(fileName, fileSize, expectedHash, actualHash) {
                const mismatchRow = document.createElement('tr');
                mismatchRow.innerHTML = `
                    <td>${fileName}</td>
                    <td>${fileSize}</td>
                    <td class="file-hash">${expectedHash}</td>
                    <td class="file-hash">${actualHash}</td>
                `;
                return mismatchRow;
            }
        };
        // General Utility Functions
        const utils = {
            formatSize(bytes) {
                const units = ['B', 'KB', 'MB', 'GB'];
                let value = Number(bytes);
                let unit = 0;
                while (value >= 1024 && unit < units.length - 1) {
                    value /= 1024;
                    unit++;
                }
                return `${value.toFixed(1)} ${units[unit]}`;
            },
            formatHash(hash) {
                return Array.from(hash)
                    .map(b => b.toString(16).padStart(2, '0'))
                    .join('');
            },
            formatDate(date) {
                return new Intl.DateTimeFormat('default', {
                    year: 'numeric',
                    month: 'short',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit'
                }).format(date);
            },
            isFolder(hash) {
                return typeof hash === 'string' ?
                    hash === '0000000000000000000000000000000000000000' :
                    this.formatHash(hash) === '0000000000000000000000000000000000000000';
            },
            isNonEmptyFolder(file, allFiles) {
                if (!this.isFolder(file.FileHash)) return false;
                return allFiles.some(f => f.FileName.startsWith(file.FileName + '/'));
            },
            normalizePath(path) {
                path = path.replace(/\\/g, '/');
                path = path.replace(/^\/+|\/+$/g, '');
                path = path.replace(/^\.\//, '');
                path = path.replace(/\/+/g, '/');
                return path.toLowerCase();
            },
            findMatchingFile(fileName) {
                if (!window.currentManifest?.Files) return null;
                const normalizedInput = this.normalizePath(fileName);
                const files = window.currentManifest.Files;
                const exactMatch = files.find(f =>
                    this.normalizePath(f.FileName) === normalizedInput
                );
                if (exactMatch) return exactMatch;
                const inputParts = normalizedInput.split('/');
                const inputBaseName = inputParts[inputParts.length - 1];
                const inputDirectory = inputParts.slice(0, -1).join('/');
                const candidates = files.filter(f => {
                    const manifestPath = this.normalizePath(f.FileName);
                    const manifestParts = manifestPath.split('/');
                    const manifestBaseName = manifestParts[manifestParts.length - 1];
                    return manifestBaseName === inputBaseName;
                });
                if (candidates.length === 0) return null;
                if (candidates.length === 1) return candidates[0];
                let bestMatch = null;
                let bestScore = -1;
                for (const candidate of candidates) {
                    const manifestPath = this.normalizePath(candidate.FileName);
                    const manifestParts = manifestPath.split('/');
                    const manifestDirectory = manifestParts.slice(0, -1).join('/');
                    let score = 0;
                    if (manifestDirectory === inputDirectory) {
                        score = 1000;
                    } else if (inputDirectory && manifestDirectory) {
                        const inputDirParts = inputDirectory.split('/');
                        const manifestDirParts = manifestDirectory.split('/');
                        for (let i = 1; i <= Math.min(inputDirParts.length, manifestDirParts.length); i++) {
                            if (inputDirParts[inputDirParts.length - i] ===
                                manifestDirParts[manifestDirParts.length - i]) {
                                score += 10;
                            } else {
                                break;
                            }
                        }
                    }
                    if (score > bestScore) {
                        bestScore = score;
                        bestMatch = candidate;
                    }
                }
                return bestScore >= 10 ? bestMatch : null;
            },
            parseSHA1File(content) {
                const lines = content.split(/[\r\n]+/).filter(line => line.trim());
                const files = [];
                const seenFiles = new Set();
                lines.forEach((line, index) => {
                    line = line.trim().replace(/^\uFEFF/, '');
                    if (!line || line.startsWith('#')) return;
                    try {
                        let hash, fileName, fileSize;
                        let match = line.match(/([a-fA-F0-9]{40})\s+[*]?(.+)/i);
                        if (match) {
                            [, hash, fileName] = match;
                        } else {
                            match = line.match(/SHA1\((.+?)\)[= ]+([a-fA-F0-9]{40})/i);
                            if (match) {
                                [, fileName, hash] = match;
                            } else {
                                // SteamDB format
                                match = line.match(/(.+?)\t([a-fA-F0-9*]{23})\t(\d+)/i);
                                if (match) {
                                    [, fileName, hash, fileSize] = match;
                                } else {
                                    match = line.match(/([a-fA-F0-9]{40})/i);
                                    if (match) {
                                        hash = match[1];
                                        fileName = line.replace(hash, '').trim();
                                        if (!fileName) fileName = `file_${index}`;
                                    }
                                }
                            }
                        }
                        if (hash && fileName) {
                            fileName = fileName.trim().replace(/\\/g, '/');
                            const fileKey = `${fileName}|${hash}`;
                            if (!seenFiles.has(fileKey)) {
                                seenFiles.add(fileKey);
                                files.push({
                                    FileName: fileName,
                                    FileHash: hash.toLowerCase(),
                                    TotalSize: fileSize ? Number(fileSize) : 0
                                });
                            }
                        }
                    } catch (err) {
                        console.warn(`Failed to parse line ${index}:`, err);
                    }
                });
                if (files.length === 0) {
                    throw new Error(window.languageManager.getString('errors.noValidHashes'));
                }
                return {
                    Files: files,
                    DepotID: 'SHA1 File',
                    ManifestGID: 'N/A',
                    CreationTime: new Date(),
                    TotalSize: files.some(e => e.TotalSize > 0) ? files.reduce((a, c) => a.TotalSize + c.TotalSize) : 0,
                    isSHA1File: true
                };
            },
            markPendingAsMissing() {
                document.querySelectorAll('#file-list tr .status.pending').forEach(status => {
                    utils.updateStatus(status, 'mismatch');
                    const row = status.parentElement;
                    const fileName = row.children[0].textContent;
                    const fileSize = row.children[1].textContent;
                    const expectedHash = row.children[2].textContent;
                    const mismatchList = document.getElementById('mismatch-list');
                    const mismatchRow = FileProcessor.createMismatchRow(
                        fileName,
                        fileSize,
                        expectedHash,
                        window.languageManager.getString('errors.fileMissing')
                    );
                    mismatchList.appendChild(mismatchRow);
                });
                if (document.getElementById('mismatch-list').children.length > 0) {
                    document.getElementById('mismatches').classList.remove('hidden');
                }
            },
            showError(message) {
                const error = document.getElementById('error');
                error.innerHTML = `
                    <span class="material-icons">error</span>
                    <span class="error-message">${message}</span>
                `;
                error.classList.remove('hidden');
                document.getElementById('metadata').classList.add('hidden');
                document.getElementById('files').classList.add('hidden');
                document.getElementById('mismatches').classList.add('hidden');
            },
            hideError() {
                document.getElementById('error').classList.add('hidden');
            },
            updateStatus(element, status) {
                const icons = {
                    match: 'check_circle',
                    mismatch: 'error',
                    pending: 'pending',
                    folder: 'folder'
                };
                const statusText = window.languageManager.getString(`status.${status}`);
                element.innerHTML = `
                    <span class="material-icons">${icons[status]}</span>
                    ${statusText}
                `;
                element.className = `status ${status}`;
            }
        };
        // Main Functions
        async function handleDirectory(files) {
            if (!files.length || !window.currentManifest) {
                utils.showError(!window.currentManifest ?
                    window.languageManager.getString('errors.loadManifest') :
                    window.languageManager.getString('errors.noFiles'));
                return;
            }
            utils.hideError();
            const progress = ProgressManager.create();
            const sha1 = await hashwasm.createSHA1();
            const chunkSize = 8 * 1024 * 1024;
            let processedBytes = 0;
            let startTime = Date.now();
            try {
                for (const file of files) {
                    sha1.init();
                    let chunkOffset = 0;
                    while (chunkOffset < file.size) {
                        const chunkSize = Math.min(8 * 1024 * 1024, file.size - chunkOffset);
                        const chunk = await FileProcessor.readChunk(file, chunkOffset, chunkSize);
                        sha1.update(new Uint8Array(chunk));
                        processedBytes += chunkSize;
                        chunkOffset += chunkSize;
                        if (chunkOffset === file.size) {
                            const relativePath = FileProcessor.getRelativePath(file);
                            console.log('Processing file:', relativePath);
                            updateFileStatuses(sha1.digest(), file.size, relativePath);
                        }
                        const elapsed = (Date.now() - startTime) / 1000;
                        const speed = processedBytes / elapsed;
                        ProgressManager.update({
                            matches: document.querySelectorAll('#file-list tr .status.match').length,
                            total: document.querySelectorAll('#file-list tr').length -
                                document.querySelectorAll('#file-list tr .status.folder').length,
                            speed: utils.formatSize(speed) + '/s'
                        });
                    }
                }
            } catch (error) {
                utils.showError(window.languageManager.getString('errors.processingError') + ' ' + error.message);
            } finally {
                utils.markPendingAsMissing();
                const totalCheckableFiles = document.querySelectorAll('#file-list tr').length -
                    document.querySelectorAll('#file-list tr .status.folder').length;
                const completedFiles = document.querySelectorAll('#file-list tr .status.match').length;
                if (completedFiles === totalCheckableFiles) {
                    ProgressManager.remove();
                }
            }
        }
        async function handleManifestFile(file) {
            const resolver = async (e = null) => {
                try {
                    utils.hideError();
                    let uploadedManifest;
                    const content = e === null ? file : new TextDecoder().decode(e.target.result);
                    if (e === null ||
                        file.name.toLowerCase().endsWith('.sha1') ||
                        file.type === 'text/plain' ||
                        content.includes('sha1') ||
                        content.match(/[a-fA-F0-9]{40}/i)) {
                        try {
                            uploadedManifest = utils.parseSHA1File(content);
                        } catch (sha1Err) {
                            if (e === null) {
                                throw sha1Err;
                            }
                            uploadedManifest = await Manifest.fromBuffer(e.target.result);
                        }
                    } else {
                        uploadedManifest = await Manifest.fromBuffer(e.target.result);
                    }
                    displayManifest(uploadedManifest);
                } catch (err) {
                    console.error('Error parsing file:', err);
                    utils.showError(window.languageManager.getString('errors.invalidFormat') + ' ' + err.message);
                }
            };
            if (typeof file === "string") {
                resolver();
                return;
            }
            const reader = new FileReader();
            reader.onload = resolver;
            reader.readAsArrayBuffer(file);
        }
        function updateFileStatuses(hash, fileSize, fileName) {
            const manifestFile = utils.findMatchingFile(fileName);
            if (!manifestFile || utils.isFolder(manifestFile.FileHash)) return;
            const expectedHash = window.currentManifest.isSHA1File ?
                manifestFile.FileHash :
                utils.formatHash(manifestFile.FileHash);
            const actualHash = typeof hash === 'string' ? hash : utils.formatHash(hash);
            const matchStatus = (() => {
                // Check file size
                if (manifestFile.TotalSize !== fileSize) {
                    return 'mismatch';
                }
                // Check SHA1
                const actualHashL = actualHash.toLowerCase();
                if (expectedHash.includes('*')) {
                    return expectedHash.substring(0, 10) === actualHashL.substring(0, 10) &&
                        expectedHash.substring(13) === actualHashL.substring(actualHashL.length - 10) ? 'match' : 'mismatch';
                } else {
                    return expectedHash.toLowerCase() === actualHashL ? 'match' : 'mismatch';
                }
            })();
            document.querySelectorAll('#file-list tr').forEach(row => {
                const rowFileName = row.children[0].textContent;
                if (rowFileName === manifestFile.FileName) {
                    utils.updateStatus(row.querySelector('.status'), matchStatus);
                    if (matchStatus === 'mismatch') {
                        const mismatchList = document.getElementById('mismatch-list');
                        const mismatchRow = FileProcessor.createMismatchRow(
                            manifestFile.FileName,
                            row.children[1].textContent,
                            expectedHash,
                            actualHash
                        );
                        mismatchList.appendChild(mismatchRow);
                        document.getElementById('mismatches').classList.remove('hidden');
                    }
                }
            });
            updateCompletionStatus();
        }
        function updateCompletionStatus() {
            const completedFiles = document.querySelectorAll('#file-list tr .status.match').length;
            const totalCheckableFiles = document.querySelectorAll('#file-list tr').length -
                document.querySelectorAll('#file-list tr .status.folder').length;
            const mismatchedFiles = document.querySelectorAll('#file-list tr .status.mismatch').length;
            let statusType = 'pending';
            if (completedFiles > 0) {
                if (completedFiles === totalCheckableFiles) {
                    statusType = mismatchedFiles === 0 ? 'match' : 'mismatch';
                } else if (mismatchedFiles > 0) {
                    statusType = 'mismatch';
                }
            }
            utils.updateStatus(document.getElementById('completion-status'), statusType);
        }
        function displayManifest(manifest) {
            try {
                window.currentManifest = manifest;
                document.getElementById('mismatch-list').innerHTML = '';
                document.getElementById('mismatches').classList.add('hidden');
                document.getElementById('file-type').textContent = manifest.isSHA1File ?
                    window.languageManager.getString('fileInfo.types.sha1') :
                    window.languageManager.getString('fileInfo.types.steam');
                document.getElementById('depot-id').textContent = manifest.DepotID;
                document.getElementById('manifest-gid').textContent = manifest.ManifestGID?.toString();
                document.getElementById('creation-time').textContent = utils.formatDate(manifest.CreationTime);
                // Get the current state of the folder toggle
                const hideFolders = localStorage.getItem('hideFolders') === 'true';
                // Filter files based on the toggle state
                const filteredFiles = manifest.Files.filter(file =>
                    hideFolders ? !utils.isFolder(file.FileHash) : true
                );
                const fileList = document.getElementById('file-list');
                fileList.innerHTML = '';
                filteredFiles.forEach(file => {
                    const row = document.createElement('tr');
                    const isFolder = utils.isFolder(file.FileHash);
                    row.innerHTML = `
                        <td>${file.FileName}</td>
                        <td>${isFolder ? window.languageManager.getString('status.folder') : utils.formatSize(file.TotalSize)}</td>
                        <td class="file-hash">${isFolder ? window.languageManager.getString('status.folder') : (manifest.isSHA1File ? file.FileHash : utils.formatHash(file.FileHash))}</td>
                        <td class="status ${isFolder ? 'folder' : 'pending'}">
                            <span class="material-icons">${isFolder ? 'folder' : 'pending'}</span>
                            ${isFolder ? window.languageManager.getString('status.folder') : window.languageManager.getString('status.pending')}
                        </td>
                    `;
                    fileList.appendChild(row);
                });
                // Only count non-folder files for the totals
                const nonFolderFiles = manifest.Files.filter(file => !utils.isFolder(file.FileHash));
                document.getElementById('total-files').textContent = nonFolderFiles.length;
                document.getElementById('total-size').textContent = utils.formatSize(nonFolderFiles.reduce((sum, file) =>
                    sum + Number(file.TotalSize), 0));
                utils.updateStatus(document.getElementById('completion-status'), 'pending');
                document.getElementById('metadata').classList.remove('hidden');
                document.getElementById('files').classList.remove('hidden');
                utils.hideError();
            } catch (err) {
                console.error('Error:', err);
                utils.showError(err.message);
            }
        }
        function initThemes() {
            const themeSelect = document.getElementById('theme-select');
            const savedTheme = localStorage.getItem('theme') || 'steam';
            for (const option of themeSelect.options) {
                option.setAttribute('data-lang', `app.themes.${option.value}`);
            };
            document.documentElement.setAttribute('data-theme', savedTheme);
            themeSelect.value = savedTheme;
            themeSelect.addEventListener('change', (e) => {
                const newTheme = e.target.value;
                document.documentElement.setAttribute('data-theme', newTheme);
                localStorage.setItem('theme', newTheme);
            });
        }
        function initializeUI() {
            // File upload handlers
            document.getElementById('file-input').addEventListener('change', (e) => {
                if (e.target.files[0]) handleManifestFile(e.target.files[0]);
            });
            document.getElementById('dir-input').addEventListener('change', (e) => {
                if (e.target.files.length) handleDirectory(Array.from(e.target.files));
            });
            // Raw input handler
            document.getElementById('raw-input').addEventListener('change', (e) => {
                if (typeof e.target.value === 'string' && e.target.value !== '') handleManifestFile(e.target.value);
            })
            // Initialize folder toggle
            const folderToggle = document.getElementById('folder-toggle');
            const folderToggleText = document.getElementById('folder-toggle-text');
            let hideFolders = localStorage.getItem('hideFolders') === 'true';
            folderToggleText.textContent = window.languageManager.getString(`app.folderToggle.${hideFolders ? 'show' : 'hide'}`);
            folderToggle.addEventListener('click', () => {
                hideFolders = !hideFolders;
                localStorage.setItem('hideFolders', hideFolders);
                folderToggleText.textContent = window.languageManager.getString(`app.folderToggle.${hideFolders ? 'show' : 'hide'}`);
                if (window.currentManifest) {
                    displayManifest(window.currentManifest);
                }
            });
            // Initialize drag and drop for both zones
            ['drop-zone', 'dir-zone'].forEach(id => {
                const element = document.getElementById(id);
                element.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    element.classList.add('drag-over');
                });
                element.addEventListener('dragleave', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    element.classList.remove('drag-over');
                });
                element.addEventListener('drop', async (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    element.classList.remove('drag-over');
                    if (id === 'drop-zone' && e.dataTransfer.files[0]) {
                        handleManifestFile(e.dataTransfer.files[0]);
                    } else if (id === 'dir-zone') {
                        const items = e.dataTransfer.items;
                        const files = [];
                        async function getAllFiles(entry) {
                            if (entry.isFile) {
                                return new Promise((resolve) => {
                                    entry.file(file => {
                                        const pathParts = entry.fullPath.split('/');
                                        file.webkitRelativePath = pathParts.slice(2).join('/') || file.name;
                                        files.push(file);
                                        resolve();
                                    }, (err) => {
                                        console.warn(`Failed to read file: ${entry.fullPath}`, err);
                                        resolve();
                                    });
                                });
                            } 
                            else if (entry.isDirectory) {
                                const reader = entry.createReader();
                                const entries = [];
                                
                                const readBatch = () => new Promise((resolve, reject) => {
                                    reader.readEntries(resolve, reject);
                                });

                                try {
                                    let batch;
                                    do {
                                        batch = await readBatch();
                                        entries.push(...batch);
                                    } while (batch.length > 0);
                                    
                                    const promises = entries.map(entry => getAllFiles(entry));
                                    await Promise.all(promises);
                                } catch (err) {
                                    console.warn(`Error reading directory: ${entry.fullPath}`, err);
                                }
                            }
                        }
                        const promises = [];
                        for (const item of items) {
                            if (item.kind === 'file') {
                                const entry = item.webkitGetAsEntry();
                                if (entry) {
                                    promises.push(getAllFiles(entry));
                                }
                            }
                        }
                        await Promise.all(promises);
                        if (files.length > 0) {
                            handleDirectory(files);
                        }
                    }
                });
            });
        }
        // Initialize and start the application
        async function init() {
            initThemes();
            const languageManager = new LanguageManager('https://raw.githubusercontent.com/MorrenusGames/steam-manifest-hash-checker-HTML/main');
            await languageManager.init();
            window.languageManager = languageManager;
            initializeUI();
        }
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>